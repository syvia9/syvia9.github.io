
1. decide which port(slice/ifg/serdes_id) is used for the la_mac_port
   step 1.
    check https://cisco-my.sharepoint.com/:x:/p/xiaocfan/EYShpoLZV2JGolvVV9UgFGkBvxQBmrzQoFYGIUTFuxGpJQ?e=XEcOYY
    to add ports to IXIA
   step 2.
    send 50~100% traffic from the IXIA
   step 3.
    go to debug shell, check get_counters(), to decide which port is receiving such a large traffic:
    below result shows: slice 4 , ifg 1 (IFG_RX8: ifg=0, IFG_RX9: ifg=1)
     
get_counters()
>>>INFO  Total Forwarding drop counter (DSP==1): packets = 432369028    , bytes = 221372942336
INFO  ____________________Slice0____________________|____________Slice1___________|____________Slice2___________|____________Slice3___________|____________Slice4___________|____________Slice5___________|
INFO  IFG_RX  9 Port  8 rx_errored_blocks_cnt      = 1533
INFO  IFG_RX0 packets          =               2    |IFG_RX2 =               0    |IFG_RX4 =               0    |IFG_RX6 =               0    |IFG_RX8 =               0    |IFG_RX10 =               0    |
INFO  IFG_RX1 packets          =               0    |IFG_RX3 =               2    |IFG_RX5 =               0    |IFG_RX7 =               0    |IFG_RX9 =       432349465    |IFG_RX11 =               0    |
INFO  IFG_RX0 bytes            =             468    |IFG_RX2 =               0    |IFG_RX4 =               0    |IFG_RX6 =               0    |IFG_RX8 =               0    |IFG_RX10 =               0    |
INFO  IFG_RX1 bytes            =               0    |IFG_RX3 =             468    |IFG_RX5 =               0    |IFG_RX7 =               0    |IFG_RX9 =    221362926080    |IFG_RX11 =               0    |
INFO  IFGB_RX0 packets         =               2    |IFG_RX2 =               0    |IFG_RX4 =               0    |IFG_RX6 =               0    |IFG_RX8 =               0    |IFG_RX10 =               0    |
INFO  IFGB_RX1 packets         =               0    |IFG_RX3 =               2    |IFG_RX5 =               0    |IFG_RX7 =               0    |IFG_RX9 =       432398897    |IFG_RX11 =               0    |
INFO  IFGB_RX0 host packets    =              31    |IFGB2   =               0    |IFGB4   =               0    |IFGB6   =               0    |IFGB8   =               0    |IFGB10   =               0    |
INFO  IFGB_RX1 host packets    =               0    |IFGB3   =               0    |IFGB5   =               0    |IFGB7   =               0    |IFGB9   =               0    |IFGB11   =               0    |
INFO  IFGB_RX0 sch recycle     =               4    |IFGB2   =               0    |IFGB4   =               0    |IFGB6   =               0    |IFGB8   =               0    |IFGB10   =               0    |
INFO  IFGB_RX1 sch recycle     =               0    |IFGB3   =               0    |IFGB5   =               0    |IFGB7   =               0    |IFGB9   =               0    |IFGB11   =               0    |
INFO  RXPP IFG0 input packets  =              37    |RXPP2   =               0    |RXPP4   =               0    |RXPP6   =               0    |RXPP8   =               0    |RXPP10   =               0    |
INFO  RXPP IFG1 input packets  =               0    |RXPP3   =               2    |RXPP5   =               0    |RXPP7   =               0    |RXPP9   =       432337047    |RXPP11   =               0    |
INFO  RXPP IFG0 output packets =              37    |RXPP2   =               0    |RXPP4   =               0    |RXPP6   =               0    |RXPP8   =               0    |RXPP10   =               0    |
INFO  RXPP IFG1 output packets =               0    |RXPP3   =               2    |RXPP5   =               0    |RXPP7   =               0    |RXPP9   =       432335812    |RXPP11   =               0    |
INFO  Ongoing fwd destination of DSP==1: Slice 4, Number of droped packets is 1945920      (in 0.1 seconds)
INFO  SMS IFG0 write packets   =              37    |SMS2    =               0    |SMS4    =               0    |SMS6    =               0    |SMS8    =               0    |SMS 10   =               0    |
INFO  SMS IFG1 write packets   =               0    |SMS3    =               2    |SMS5    =               0    |SMS7    =               0    |SMS9    =       432067905    |SMS 11   =               0    |
INFO  REASSEMBLY Slc0 packets  =              37    |REAS1   =               2    |REAS2   =               0    |REAS3   =               0    |REAS4   =       431776066    |REAS5    =               0    |
INFO  PDVOQ Slice0 packets     =              37    |PDVOQ1  =               2    |PDVOQ2  =               0    |PDVOQ3  =               0    |PDVOQ4  =       431269647    |PDVOQ5   =               0    |
INFO  PDVOQ Slice0 bytes       =           11145    |PDVOQ1  =             540    |PDVOQ2  =               0    |PDVOQ3  =               0    |PDVOQ4  =    236335766556    |PDVOQ5   =               0    |
INFO  PDVOQ Slc0 drop packets  =               0    |PDVOQ1  =               0    |PDVOQ2  =               0    |PDVOQ3  =               0    |PDVOQ4  =        11839247 (*)|PDVOQ5   =               0    |
INFO  PDVOQ DROP COUNTERS: sms_buffers_drop_green      =       431277587
INFO  PDVOQ DROP COUNTERS: sms_pkts_drop_green         =       431277587

 
>>>debug_device.read_register(gibraltar_tree.slice[5].ifg[0].ifgb.fc_cfg0)
>>>periodic_int_en [23:0] = 0x0000000

>>>mp0 = la_device.get_mac_port()
>>>Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: get_mac_port() missing 3 required positional arguments: 'slice_id', 'ifg_id', and 'serdes_id'
>>> mp0 = la_device.get_mac_port(4,1,0)
>>> mp0.get_state()
>>>  File "<stdin>", line 1
    mp0.get_state()
    ^
IndentationError: unexpected indent
mp0.get_state()
>>>15
>>>mp0 = la_device.get_mac_port(4,1,1)
>>>mp0.get_state()
>>>15
>>>mp0 = la_device.get_mac_port(4,1,7)
>>>Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/cisco/pylib/leaba/../leaba/sdk.py", line 15671, in get_mac_port
    return _sdk.la_device_get_mac_port(self, slice_id, ifg_id, serdes_id)
Leaba.NotFoundException: (25, 'Leaba_Err: Entry requested not found: virtual la_status silicon_one::la_device_impl::get_mac_port_internal(la_slice_id_t, la_ifg_id_t, la_uint_t, silicon_one::la_mac_port*&) const:src/hld/system/la_device_impl.cpp:7148')

>>>mp0 = la_device.get_mac_port(4,1,6)
>>>Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/cisco/pylib/leaba/../leaba/sdk.py", line 15671, in get_mac_port
    return _sdk.la_device_get_mac_port(self, slice_id, ifg_id, serdes_id)
Leaba.NotFoundException: (25, 'Leaba_Err: Entry requested not found: virtual la_status silicon_one::la_device_impl::get_mac_port_internal(la_slice_id_t, la_ifg_id_t, la_uint_t, silicon_one::la_mac_port*&) const:src/hld/system/la_device_impl.cpp:7148')

>>>mp0 = la_device.get_mac_port(4,1,2)
>>>mp0.get_state()
>>>15
>>>mp0 = la_device.get_mac_port(4,1,3)
>>>mp0.get_state()
>>>15
>>>mp0 = la_device.get_mac_port(4,1,4)
>>>Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/cisco/pylib/leaba/../leaba/sdk.py", line 15671, in get_mac_port
    return _sdk.la_device_get_mac_port(self, slice_id, ifg_id, serdes_id)
Leaba.NotFoundException: (25, 'Leaba_Err: Entry requested not found: virtual la_status silicon_one::la_device_impl::get_mac_port_internal(la_slice_id_t, la_ifg_id_t, la_uint_t, silicon_one::la_mac_port*&) const:src/hld/system/la_device_impl.cpp:7148')


2. to check how to config PFC in this environment:
change script:
def test_hw_pfc_oq_state(self):        
        self.init_common()
        self.mac_port.set_fc_mode(sdk.la_mac_port.fc_direction_e_BIDIR,
                                  sdk.la_mac_port.fc_mode_e_PFC)
        self.pfc_rx_counter = self.device.create_counter(8)
        self.mac_port.set_pfc_enable((1 << TC_VALUE))
        self.mac_port.set_pfc_quanta(100)
        self.dd = debug_utils.debug_device(self.device)
        self.ll_device = self.device.get_ll_device()
        self.tree = sim_utils.get_device_tree(self.ll_device)
        #send a PFC packet to a network port and loopback into this very port
        import pdb
        pdb.set_trace()
----------->
 mp0 = la_device.get_mac_port(4,1,0)
 mp0.set_fc_mode(sdk.la_mac_port.fc_direction_e_BIDIR, sdk.la_mac_port.fc_mode_e_PFC)
 
 check if the register is set properly:
 >>>debug_device.read_register(gibraltar_tree.slice[4].ifg[1].ifgb.fc_cfg0)
>>>periodic_int_en [23:0] = 0x0000000


>>>mp0.set_pfc_enable((1 << 5))
>>>debug_device.read_register(gibraltar_tree.slice[4].ifg[1].ifgb.fc_cfg0)
>>>periodic_int_en [23:0] = 0x0000001

It seems OK, good job!!
3. to check if PFC packet is sent periodically
yes.
4. capture packet from  IXIA:
0180c2000001000000000001880801010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a6df3ffa
 it is almost the very same as I captured on Israel churchill:
0180c20000011234123412348808010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000007a6a5e91000000007a6a5e910000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000180c200000112340111110000807ff7ffff700233000007ffff000000000000000000010030779bc1000000000000280000002000e7c00000000000000000000000007ff0000000060203800030000000000000000000140041000700000000000000000000000000000e000e180001

So here is the conclusion:
PFC send only ncontrol flow based on link(port), not on priority.

5.check tx timer settings:
>>>debug_device.read_register(gibraltar_tree.slice[4].ifg[1].mac_pool8[0].tx_mac_fc_per_xoff_timer[0])
>>>tx_fc_per_xoff_timer [15:0] = 0x0ffff
tx_fc_per_xoff_en [23:16] = 0x020
>>>debug_device.read_register(gibraltar_tree.slice[4].ifg[1].mac_pool8[0].tx_mac_fc_per_xoff_timer[1])
>>>tx_fc_per_xoff_timer [15:0] = 0x0ffff
tx_fc_per_xoff_en [23:16] = 0x020
>>>debug_device.read_register(gibraltar_tree.slice[4].ifg[1].mac_pool8[0].tx_mac_fc_per_xoff_timer[2])
>>>tx_fc_per_xoff_timer [15:0] = 0x0ffff
tx_fc_per_xoff_en [23:16] = 0x020
>>>debug_device.read_register(gibraltar_tree.slice[4].ifg[1].mac_pool8[0].tx_mac_fc_per_xoff_timer[3])
>>>tx_fc_per_xoff_timer [15:0] = 0x0ffff
tx_fc_per_xoff_en [23:16] = 0x020
>>>debug_device.read_register(gibraltar_tree.slice[4].ifg[1].mac_pool8[0].tx_mac_fc_per_xoff_timer[4])
>>>tx_fc_per_xoff_timer [15:0] = 0x0ffff
tx_fc_per_xoff_en [23:16] = 0x0ff

>>>debug_device.read_register(gibraltar_tree.slice[4].ifg[1].mac_pool8[1].tx_mac_fc_per_xoff_timer[0])
>>>tx_fc_per_xoff_timer [15:0] = 0x0ffff
tx_fc_per_xoff_en [23:16] = 0x0ff


debug_device.write_register(gibraltar_tree.slice[4].ifg[1].mac_pool8[0].tx_mac_fc_per_xoff_timer[0],0xffffff)

6. close the periodically sending:
debug_device.write_register(gibraltar_tree.slice[4].ifg[1].ifgb.fc_cfg0,0)
check if the PFC packet has been stopped
get_counters()
YES

7. send PFC packet by IXIA, 10 packets/s
(Pdb) debug_device.read_register(gibraltar_tree.slice[4].ifg[1].ifgb.fcm_wd_expired_counter[0])
port_wd_expired [31:0] = 0x000000000

I read it several times , the pfc_status  with index 0 is always ZERO
(Pdb) debug_device.read_register(gibraltar_tree.slice[4].pdoq.top.pfc_debug_cfg)
pfc_status_select [3:0] = 0x00

(Pdb) debug_device.read_register(gibraltar_tree.slice[4].pdoq.top.pfc_debug)
pfc_status [31:0] = 0x000000000

PDOQ status is still 0 

8. change the rx ternimate condition:
debug_device.read_register(gibraltar_tree.slice[4].ifg[1].mac_pool8[0].rx_mac_cfg0[0])

>>>rx_crc_check [0:0] = 0x1
rx_crc_oob_check [1:1] = 0x1
rx_oob_intrlv_type_filt_en [2:2] = 0x1
rx_oob_intrlv_inb_type_filt_en [3:3] = 0x1
rx_cnt_ka_en [4:4] = 0x1
rx_crc_strip [5:5] = 0x1
rx_ctrl_pkts64b60b [6:6] = 0x0
rx_ctrl_pkts_term [7:7] = 0x1
rx_ctrl_pkts_term_by_address [8:8] = 0x0
rx_fc_mode [10:9] = 0x2
rx_link_interruption_en [11:11] = 0x1

enable rx_ctrl_pkts_term_by_address:
debug_device.write_register(gibraltar_tree.slice[4].ifg[1].mac_pool8[0].rx_mac_cfg0[0],0xdbf)
>>>rx_crc_check [0:0] = 0x1ter(gibraltar_tree.slice[4].ifg[1].mac_pool8[0].rx_mac
rx_crc_oob_check [1:1] = 0x1
rx_oob_intrlv_type_filt_en [2:2] = 0x1
rx_oob_intrlv_inb_type_filt_en [3:3] = 0x1
rx_cnt_ka_en [4:4] = 0x1
rx_crc_strip [5:5] = 0x1
rx_ctrl_pkts64b60b [6:6] = 0x0
rx_ctrl_pkts_term [7:7] = 0x1
rx_ctrl_pkts_term_by_address [8:8] = 0x1
rx_fc_mode [10:9] = 0x2
rx_link_interruption_en [11:11] = 0x1

the fcm and pdoq are still 0
(Pdb) debug_device.read_register(gibraltar_tree.slice[4].ifg[1].ifgb.fcm_wd_expired_counter[0])
port_wd_expired [31:0] = 0x000000000

I read it several times , the pfc_status  with index 0 is always ZERO
(Pdb) debug_device.read_register(gibraltar_tree.slice[4].pdoq.top.pfc_debug_cfg)
pfc_status_select [3:0] = 0x00

(Pdb) debug_device.read_register(gibraltar_tree.slice[4].pdoq.top.pfc_debug)
pfc_status [31:0] = 0x000000000

9. read mib counters:
too bad, the packet is not recognized as a valid PFC packet...
mib_counters = mp0.read_mib_counters(False)
print(mib_counters.rx_mac_fc_frames_ok)
>>>print(mib_counters.rx_mac_fc_frames_ok)
>>>0
print(mib_counters.rx_mac_fc_frames_ok)
>>>0
print(mib_counters.rx_mac_fc_frames_ok)
>>>0
print(mib_counters.rx_mac_fc_frames_ok)
>>>0
>>> print(mib_counters.rx_mac_fc_frames_ok)
>>>0

10. recover the rx_mac_cfg0
the mib counter  increased:
getmib_counters = mp0.read_mib_counters(False)
>>>print(mib_counters.rx_mac_fc_frames_ok)
>>>9228
primib_counters = mp0.read_mib_counters(False)
>>>print(mib_counters.rx_mac_fc_frames_ok)
>>>13109


11.modify the PFC packet ethernet header src-address to the same as that of packets sent from chip
000000000001

the mib counter  increased as well.


